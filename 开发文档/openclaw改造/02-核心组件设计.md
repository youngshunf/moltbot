# Openclaw 多租户 SaaS 化改造方案 - 核心组件设计

## 0. 现有架构研究（必读）

在开始设计前，必须理解 Openclaw 现有的架构模式：

### 现有配置加载机制
```typescript
// src/config/io.ts 使用工厂模式
export function createConfigIO(overrides: ConfigIoDeps = {}) {
  // 返回包含 loadConfig/saveConfig 等方法的对象
}

// 而非简单的 loadConfig(userId) 函数
```

### 现有认证机制
```typescript
// src/gateway/auth.ts 支持多种认证方式
export type GatewayAuthResult = {
  ok: boolean;
  method?: "token" | "password" | "tailscale" | "device-token";
  user?: string;
  reason?: string;
};

// 认证函数是异步的，支持 Tailscale whois 验证
export async function authorizeGatewayConnect(params: {
  auth: ResolvedGatewayAuth;
  connectAuth?: ConnectAuth | null;
  req?: IncomingMessage;
  trustedProxies?: string[];
  tailscaleWhois?: TailscaleWhoisLookup;
}): Promise<GatewayAuthResult>;
```

### 现有路径解析工具
```typescript
// 应使用现有的路径解析函数，而非硬编码
import { resolveUserPath } from '../utils.js';
import { resolveOpenClawAgentDir } from '../agents/agent-paths.js';
import { resolveStateDir } from '../config/paths.js';
```

---

## 1. 目录结构设计

### 独立数据目录（生产环境推荐）

```
/data/openclaw/                      # 数据根目录（可配置）
├── configs/                        # 配置目录
│   └── users/
│       ├── user_123/
│       │   ├── openclaw.json       # 用户专属配置
│       │   ├── token              # Gateway auth token
│       │   └── credentials/       # LLM API keys
│       └── user_456/
│           ├── openclaw.json
│           ├── token
│           └── credentials/
│
├── workspaces/                     # 工作区目录
│   ├── template/                   # 共享模板（只读）
│   │   ├── AGENTS.md              # Agent 行为指南
│   │   ├── SOUL.md                # 人格和语气
│   │   ├── USER.md                # 用户信息
│   │   ├── IDENTITY.md            # Agent 身份
│   │   ├── TOOLS.md               # 工具使用说明
│   │   └── HEARTBEAT.md           # 心跳检查清单
│   │
│   └── users/                      # 用户工作区数据
│       ├── user_123/
│       │   ├── memory/            # 用户记忆
│       │   │   ├── 2026-01-30.md # 每日记忆
│       │   │   └── 2026-01-31.md
│       │   ├── sessions/          # 会话记录
│       │   │   └── session_xxx.jsonl
│       │   └── custom/            # 用户自定义文件（覆盖模板）
│       │       └── AGENTS.md      # 如果存在，优先使用
│       └── user_456/
│           ├── memory/
│           ├── sessions/
│           └── custom/
│
└── logs/                           # 日志目录
    ├── gateway.log                # Gateway 主日志
    └── users/                     # 用户日志（可选）
        ├── user_123.log
        └── user_456.log
```

### 全局配置文件

**位置**：`/etc/openclaw/config.json` 或 `~/.clawdbot/openclaw.json`

```json5
{
  "multiTenant": {
    "enabled": true,
    "cloudBackendUrl": "https://your-cloud-backend.com",
    "configRoot": "/data/openclaw/configs",        // 用户配置根目录
    "workspaceRoot": "/data/openclaw/workspaces",  // 工作区根目录
    "templatePath": "/data/openclaw/workspaces/template",
    "maxCachedUsers": 100,                        // 最大缓存用户数
    "userIdleTimeoutMs": 3600000,                 // 用户空闲超时（1小时）
    "syncIntervalMs": 300000                      // 配置同步间隔（5分钟）
  },
  "gateway": {
    "port": 18789,
    "bind": "0.0.0.0"
  }
}
```

---

## 2. Multi-Tenant Gateway Manager 组件

### 核心数据结构

```typescript
// 新增文件：src/gateway/multi-tenant-manager.ts

import { LRUCache } from 'lru-cache';
import type { OpenClawConfig } from '../config/types.js';  // 注意：实际类型名是 OpenClawConfig
import type { WorkspaceFileResolver } from '../agents/workspace-resolver.js';
import { resolveUserPath } from '../utils.js';
import { createConfigIO } from '../config/io.js';

export interface UserInstance {
  userId: string;                          // 用户 ID
  token: string;                           // Gateway auth token
  config: OpenClawConfig;                  // 用户配置（注意类型名称）
  workspacePath: string;                   // 工作区路径
  workspaceResolver: WorkspaceFileResolver; // 工作区文件解析器
  lastAccess: number;                      // 最后访问时间
  connections: Set<WebSocket>;             // 活跃连接
  pendingRequests: number;                 // 进行中的请求数（防止清理时中断请求）
}

export interface MultiTenantConfig {
  enabled: boolean;
  cloudBackendUrl: string;
  configRoot: string;
  workspaceRoot: string;
  templatePath: string;
  maxCachedUsers: number;
  userIdleTimeoutMs: number;
  syncIntervalMs: number;
}
```

### 核心方法

```typescript
export class MultiTenantGatewayManager {
  private userInstances: Map<string, UserInstance>;
  private tokenToUserId: Map<string, string>;
  private configCache: LRUCache<string, OpenclawConfig>;

  constructor(private config: MultiTenantConfig) {
    this.userInstances = new Map();
    this.tokenToUserId = new Map();
    this.configCache = new LRUCache({
      max: config.maxCachedUsers,
      ttl: config.userIdleTimeoutMs
    });
  }

  /**
   * 从云端同步用户配置
   * 定期调用，更新 token 映射和本地配置文件
   */
  async syncUserConfigs(): Promise<void> {
    const url = `${this.config.cloudBackendUrl}/api/v1/openclaw/users/configs`;
    const response = await fetch(url, {
      headers: {
        'Authorization': `Bearer ${process.env.OPENCLAW_SERVICE_TOKEN}`
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to sync configs: ${response.statusText}`);
    }

    const { users } = await response.json();

    for (const user of users) {
      // 更新 token 映射
      this.tokenToUserId.set(user.gatewayToken, user.userId);

      // 写入本地配置文件
      await this.writeUserConfig(user.userId, user);
    }

    console.log(`[MultiTenant] Synced ${users.length} user configs`);
  }

  /**
   * 验证 token 并返回用户 ID
   */
  async authenticateToken(token: string): Promise<string | null> {
    return this.tokenToUserId.get(token) || null;
  }

  /**
   * 获取用户实例（懒加载）
   */
  async getUserInstance(userId: string): Promise<UserInstance> {
    let instance = this.userInstances.get(userId);

    if (!instance) {
      // 首次加载：初始化用户配置和工作区
      instance = await this.initializeUserInstance(userId);
      this.userInstances.set(userId, instance);
      console.log(`[MultiTenant] Initialized user instance: ${userId}`);
    }

    instance.lastAccess = Date.now();
    return instance;
  }

  /**
   * 初始化用户实例
   * 
   * 注意：使用现有的 createConfigIO 工厂模式加载配置
   */
  private async initializeUserInstance(userId: string): Promise<UserInstance> {
    // 1. 加载用户配置（使用现有的配置加载机制）
    const configPath = path.join(this.config.configRoot, 'users', userId, 'openclaw.json');
    const configIO = createConfigIO({ configPath });
    const config = configIO.loadConfig();

    // 2. 确保工作区存在（使用 path.join 而非字符串拼接）
    const workspacePath = path.join(this.config.workspaceRoot, 'users', userId);
    await this.ensureWorkspaceExists(workspacePath);

    // 3. 读取 token
    const tokenPath = path.join(this.config.configRoot, 'users', userId, 'token');
    const token = await fs.readFile(tokenPath, 'utf-8');

    // 4. 创建工作区解析器
    const workspaceResolver = new WorkspaceFileResolver(
      workspacePath,
      this.config.templatePath
    );

    return {
      userId,
      token: token.trim(),
      config,
      workspacePath,
      workspaceResolver,
      lastAccess: Date.now(),
      connections: new Set(),
      pendingRequests: 0  // 初始化请求计数器
    };
  }

  /**
   * 确保工作区目录存在
   */
  private async ensureWorkspaceExists(workspacePath: string): Promise<void> {
    await fs.mkdir(`${workspacePath}/memory`, { recursive: true });
    await fs.mkdir(`${workspacePath}/sessions`, { recursive: true });
    await fs.mkdir(`${workspacePath}/custom`, { recursive: true });
  }

  /**
   * 写入用户配置到本地
   */
  private async writeUserConfig(userId: string, userData: any): Promise<void> {
    const userDir = `${this.config.configRoot}/users/${userId}`;
    await fs.mkdir(userDir, { recursive: true });

    // 写入配置文件
    const configPath = `${userDir}/openclaw.json`;
    await fs.writeFile(
      configPath,
      JSON.stringify(userData.config, null, 2),
      'utf-8'
    );

    // 写入 token
    const tokenPath = `${userDir}/token`;
    await fs.writeFile(tokenPath, userData.gatewayToken, 'utf-8');

    // 写入凭证（如果有）
    if (userData.config.models?.profiles) {
      const credentialsDir = `${userDir}/credentials`;
      await fs.mkdir(credentialsDir, { recursive: true });

      for (const profile of userData.config.models.profiles) {
        if (profile.apiKey) {
          const credPath = `${credentialsDir}/${profile.id}.key`;
          await fs.writeFile(credPath, profile.apiKey, 'utf-8');
        }
      }
    }
  }

  /**
   * 清理长时间未使用的用户实例（LRU）
   * 
   * 重要：必须确保没有进行中的请求才能清理
   */
  async cleanupInactiveUsers(): Promise<void> {
    const now = Date.now();
    const cleaned: string[] = [];

    for (const [userId, instance] of this.userInstances) {
      // 确保：
      // 1. 没有活跃连接
      // 2. 没有进行中的请求（防止中断正在处理的 Agent 请求）
      // 3. 超过空闲时间
      if (instance.connections.size === 0 &&
          instance.pendingRequests === 0 &&
          now - instance.lastAccess > this.config.userIdleTimeoutMs) {
        this.userInstances.delete(userId);
        cleaned.push(userId);
      }
    }

    if (cleaned.length > 0) {
      console.log(`[MultiTenant] Cleaned up ${cleaned.length} inactive users: ${cleaned.join(', ')}`);
    }
  }

  /**
   * 增加进行中的请求计数
   */
  incrementPendingRequests(userId: string): void {
    const instance = this.userInstances.get(userId);
    if (instance) {
      instance.pendingRequests++;
    }
  }

  /**
   * 减少进行中的请求计数
   */
  decrementPendingRequests(userId: string): void {
    const instance = this.userInstances.get(userId);
    if (instance && instance.pendingRequests > 0) {
      instance.pendingRequests--;
    }
  }

  /**
   * 获取统计信息
   */
  getStats() {
    return {
      totalUsers: this.tokenToUserId.size,
      activeInstances: this.userInstances.size,
      totalConnections: Array.from(this.userInstances.values())
        .reduce((sum, inst) => sum + inst.connections.size, 0)
    };
  }
}
```

---

## 3. 工作区文件解析器

### 核心功能

```typescript
// 新增文件：src/agents/workspace-resolver.ts

import * as fs from 'fs/promises';
import * as path from 'path';

export class WorkspaceFileResolver {
  constructor(
    private userWorkspacePath: string,
    private templatePath: string
  ) {}

  /**
   * 读取工作区文件（优先用户自定义，回退到模板）
   */
  async readWorkspaceFile(filename: string): Promise<string> {
    // 1. 尝试读取用户自定义文件
    const customPath = path.join(this.userWorkspacePath, 'custom', filename);
    if (await this.exists(customPath)) {
      return await fs.readFile(customPath, 'utf-8');
    }

    // 2. 回退到模板
    const templateFilePath = path.join(this.templatePath, filename);
    if (await this.exists(templateFilePath)) {
      return await fs.readFile(templateFilePath, 'utf-8');
    }

    // 3. 返回默认内容
    return this.getDefaultContent(filename);
  }

  /**
   * 写入用户自定义文件
   */
  async writeWorkspaceFile(filename: string, content: string): Promise<void> {
    const customPath = path.join(this.userWorkspacePath, 'custom', filename);
    await fs.mkdir(path.dirname(customPath), { recursive: true });
    await fs.writeFile(customPath, content, 'utf-8');
  }

  /**
   * 获取记忆目录路径
   */
  getMemoryPath(): string {
    return path.join(this.userWorkspacePath, 'memory');
  }

  /**
   * 获取会话目录路径
   */
  getSessionsPath(): string {
    return path.join(this.userWorkspacePath, 'sessions');
  }

  /**
   * 读取今日记忆
   */
  async readTodayMemory(): Promise<string> {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const memoryPath = path.join(this.getMemoryPath(), `${today}.md`);

    if (await this.exists(memoryPath)) {
      return await fs.readFile(memoryPath, 'utf-8');
    }

    return '';
  }

  /**
   * 写入今日记忆
   */
  async writeTodayMemory(content: string): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    const memoryPath = path.join(this.getMemoryPath(), `${today}.md`);
    await fs.writeFile(memoryPath, content, 'utf-8');
  }

  /**
   * 检查文件是否存在
   */
  private async exists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 获取默认内容
   */
  private getDefaultContent(filename: string): string {
    const defaults: Record<string, string> = {
      'AGENTS.md': '# Agent 行为指南\n\n你是一个有帮助的 AI 助手。',
      'SOUL.md': '# 人格设定\n\n友好、专业、高效。',
      'USER.md': '# 用户信息\n\n用户偏好待补充。',
      'IDENTITY.md': '# Agent 身份\n\n我是你的 AI 助手。',
      'TOOLS.md': '# 工具使用说明\n\n可用工具列表待补充。',
      'HEARTBEAT.md': '# 心跳检查\n\n定期检查系统状态。'
    };

    return defaults[filename] || `# ${filename}\n\n内容待补充。`;
  }
}
```

---

## 4. 配置同步服务

```typescript
// 新增文件：src/gateway/config-sync.ts

export class ConfigSyncService {
  private syncInterval: NodeJS.Timeout | null = null;

  constructor(
    private manager: MultiTenantGatewayManager,
    private intervalMs: number
  ) {}

  /**
   * 启动配置同步服务
   */
  start(): void {
    // 立即同步一次
    this.sync();

    // 定期同步
    this.syncInterval = setInterval(() => {
      this.sync();
    }, this.intervalMs);

    console.log(`[ConfigSync] Started (interval: ${this.intervalMs}ms)`);
  }

  /**
   * 停止配置同步服务
   */
  stop(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
      console.log('[ConfigSync] Stopped');
    }
  }

  /**
   * 执行同步
   */
  private async sync(): Promise<void> {
    try {
      await this.manager.syncUserConfigs();
      console.log('[ConfigSync] Sync completed successfully');
    } catch (error) {
      console.error('[ConfigSync] Sync failed:', error);
    }
  }
}
```

---

## 5. 配置加载改造

```typescript
// 新增文件：src/config/multi-tenant.ts

export interface MultiTenantConfig {
  enabled: boolean;
  cloudBackendUrl: string;
  configRoot: string;
  workspaceRoot: string;
  templatePath: string;
  maxCachedUsers: number;
  userIdleTimeoutMs: number;
  syncIntervalMs: number;
}

/**
 * 加载全局配置
 * 优先级：环境变量 > /etc/openclaw/config.json > ~/.clawdbot/openclaw.json
 */
export function loadGlobalConfig(): { multiTenant?: MultiTenantConfig } {
  const configPath = process.env.OPENCLAW_GLOBAL_CONFIG
    || '/etc/openclaw/config.json'
    || path.join(os.homedir(), '.clawdbot', 'openclaw.json');

  try {
    const content = fs.readFileSync(configPath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.warn(`[Config] Failed to load global config from ${configPath}`);
    return {};
  }
}

/**
 * 获取多租户配置根目录
 */
export function getMultiTenantConfigRoot(): string {
  const globalConfig = loadGlobalConfig();
  return globalConfig.multiTenant?.configRoot || '/data/openclaw/configs';
}

/**
 * 获取多租户工作区根目录
 */
export function getMultiTenantWorkspaceRoot(): string {
  const globalConfig = loadGlobalConfig();
  return globalConfig.multiTenant?.workspaceRoot || '/data/openclaw/workspaces';
}

/**
 * 获取用户配置路径
 */
export function getUserConfigPath(userId: string): string {
  const configRoot = getMultiTenantConfigRoot();
  return path.join(configRoot, 'users', userId, 'openclaw.json');
}

/**
 * 获取用户工作区路径
 */
export function getUserWorkspacePath(userId: string): string {
  const workspaceRoot = getMultiTenantWorkspaceRoot();
  return path.join(workspaceRoot, 'users', userId);
}
```

---

## 总结

核心组件包括：

1. **MultiTenantGatewayManager**：管理多个用户实例，提供懒加载和 LRU 清理
2. **WorkspaceFileResolver**：解析工作区文件，支持模板回退
3. **ConfigSyncService**：定期从云端同步用户配置
4. **配置加载工具**：支持多租户配置路径解析

### 关键设计要点

- **使用现有 API**：尽量复用 `createConfigIO()`、`resolveUserPath()` 等现有函数
- **请求计数器**：`pendingRequests` 防止 LRU 清理时中断正在进行的请求
- **路径处理**：使用 `path.join()` 而非字符串拼接，确保跨平台兼容

下一步请阅读 **03-核心流程设计.md**。
