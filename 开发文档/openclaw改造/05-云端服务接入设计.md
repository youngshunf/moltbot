# Openclaw 多租户 SaaS 化改造方案 - 云端服务接入设计

## 1. 云端服务 API 设计

### 基础路径

```
https://your-cloud-backend.com/api/v1/openclaw/
```

### API 列表

#### 1.1 用户配置同步 API（供 Gateway 调用）

**接口**：`GET /api/v1/openclaw/users/configs`

**用途**：Gateway 定期调用，获取所有用户配置

**认证**：Bearer Token（服务间认证）

**请求示例**：
```bash
curl -X GET https://your-cloud-backend.com/api/v1/openclaw/users/configs \
  -H "Authorization: Bearer <gateway_service_token>"
```

**响应示例**：
```json
{
  "users": [
    {
      "userId": "user_123",
      "gatewayToken": "gt_abc123xyz",
      "config": {
        "models": {
          "profiles": [
            {
              "id": "default",
              "provider": "openai",
              "baseURL": "https://your-cloud.com/api/llm",
              "apiKey": "sk-user123-xxx",
              "model": "gpt-4"
            }
          ]
        },
        "agent": {
          "workspace": "/data/openclaw/workspaces/users/user_123"
        }
      },
      "subscription": {
        "plan": "pro",
        "credits": 1000,
        "expiresAt": "2026-02-28T00:00:00Z"
      }
    }
  ]
}
```

---

#### 1.2 用户注册/开通 API

**接口**：`POST /api/v1/openclaw/users`

**用途**：用户注册，分配 Gateway token 和 LLM API key

**请求示例**：
```json
{
  "email": "user@example.com",
  "plan": "free"
}
```

**响应示例**：
```json
{
  "userId": "user_123",
  "gatewayUrl": "wss://gateway.your-cloud.com:18789",
  "gatewayToken": "gt_abc123xyz",
  "llmApiKey": "sk-user123-xxx",
  "llmBaseUrl": "https://your-cloud.com/api/llm"
}
```

---

#### 1.3 用户配置更新 API

**接口**：`PATCH /api/v1/openclaw/users/{userId}/config`

**用途**：更新用户配置

**请求示例**：
```json
{
  "config": {
    "models": {
      "profiles": [
        {
          "id": "default",
          "model": "gpt-4-turbo"
        }
      ]
    }
  }
}
```

---

#### 1.4 使用统计上报 API（供 Gateway 调用）

**接口**：`POST /api/v1/openclaw/usage`

**用途**：Gateway 上报用户使用量，扣除积分

**请求示例**：
```json
{
  "userId": "user_123",
  "timestamp": "2026-01-30T12:00:00Z",
  "usage": {
    "inputTokens": 1000,
    "outputTokens": 500,
    "model": "gpt-4"
  }
}
```

**响应示例**：
```json
{
  "success": true,
  "creditsUsed": 40,
  "creditsRemaining": 960
}
```

---

#### 1.5 用户积分查询 API

**接口**：`GET /api/v1/openclaw/users/{userId}/credits`

**用途**：查询用户剩余积分

**响应示例**：
```json
{
  "credits": 1000,
  "used": 40,
  "remaining": 960,
  "plan": "pro",
  "expiresAt": "2026-02-28T00:00:00Z"
}
```

---

## 2. 数据库表结构设计

### 2.1 用户表（可能已存在）

```sql
CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

---

### 2.2 Openclaw 用户配置表

```sql
CREATE TABLE openclaw_users (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
  gateway_token VARCHAR(255) UNIQUE NOT NULL,  -- Gateway 认证 token
  llm_api_key VARCHAR(255) NOT NULL,           -- LLM API key
  llm_base_url VARCHAR(255) NOT NULL,          -- LLM API 地址
  config JSONB DEFAULT '{}',                   -- 用户配置（JSON）
  status VARCHAR(50) DEFAULT 'active',         -- active, suspended, deleted
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

CREATE INDEX idx_openclaw_users_gateway_token ON openclaw_users(gateway_token);
CREATE INDEX idx_openclaw_users_user_id ON openclaw_users(user_id);
CREATE INDEX idx_openclaw_users_status ON openclaw_users(status);
```

**字段说明**：
- `gateway_token`：用户专属的 Gateway 认证 token，格式：`gt_<random>`
- `llm_api_key`：用户专属的 LLM API key，格式：`sk-user<id>-<random>`
- `llm_base_url`：LLM API 地址，指向云端代理
- `config`：用户配置（JSONB），包含模型配置、工作区路径等
- `status`：用户状态（active/suspended/deleted）

---

### 2.3 订阅表

```sql
CREATE TABLE openclaw_subscriptions (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
  plan VARCHAR(50) NOT NULL,                   -- free, pro, enterprise
  credits BIGINT DEFAULT 0,                    -- 剩余积分
  credits_total BIGINT DEFAULT 0,              -- 总积分
  expires_at TIMESTAMP,                        -- 过期时间
  status VARCHAR(50) DEFAULT 'active',         -- active, expired, cancelled
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id)
);

CREATE INDEX idx_subscriptions_user_id ON openclaw_subscriptions(user_id);
CREATE INDEX idx_subscriptions_status ON openclaw_subscriptions(status);
CREATE INDEX idx_subscriptions_expires_at ON openclaw_subscriptions(expires_at);
```

**套餐说明**：
- `free`：免费版，100 积分
- `pro`：专业版，10000 积分/月
- `enterprise`：企业版，100000 积分/月

---

### 2.4 使用记录表

```sql
CREATE TABLE openclaw_usage_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
  timestamp TIMESTAMP NOT NULL,
  model VARCHAR(100) NOT NULL,
  input_tokens BIGINT NOT NULL,
  output_tokens BIGINT NOT NULL,
  credits_used BIGINT NOT NULL,                -- 本次消耗积分
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_usage_logs_user_id ON openclaw_usage_logs(user_id);
CREATE INDEX idx_usage_logs_timestamp ON openclaw_usage_logs(timestamp);
CREATE INDEX idx_usage_logs_created_at ON openclaw_usage_logs(created_at);
```

---

## 3. 云端服务实现（FastAPI）

### 3.1 数据模型

**文件**：`backend/app/models/openclaw.py`

```python
from sqlalchemy import Column, BigInteger, String, TIMESTAMP, JSON, ForeignKey
from sqlalchemy.sql import func
from backend.database import Base

class OpenclawUser(Base):
    __tablename__ = 'openclaw_users'

    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), unique=True)
    gateway_token = Column(String(255), unique=True, nullable=False)
    llm_api_key = Column(String(255), nullable=False)
    llm_base_url = Column(String(255), nullable=False)
    config = Column(JSON, default={})
    status = Column(String(50), default='active')
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

class OpenclawSubscription(Base):
    __tablename__ = 'openclaw_subscriptions'

    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), unique=True)
    plan = Column(String(50), nullable=False)
    credits = Column(BigInteger, default=0)
    credits_total = Column(BigInteger, default=0)
    expires_at = Column(TIMESTAMP)
    status = Column(String(50), default='active')
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

class OpenclawUsageLog(Base):
    __tablename__ = 'openclaw_usage_logs'

    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'))
    timestamp = Column(TIMESTAMP, nullable=False)
    model = Column(String(100), nullable=False)
    input_tokens = Column(BigInteger, nullable=False)
    output_tokens = Column(BigInteger, nullable=False)
    credits_used = Column(BigInteger, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
```

---

### 3.2 API 路由

**文件**：`backend/app/api/v1/openclaw.py`

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from backend.database import get_db
from backend.app.models.openclaw import OpenclawUser, OpenclawSubscription, OpenclawUsageLog
from backend.app.schemas.openclaw import (
    UserConfigResponse,
    CreateUserRequest,
    CreateUserResponse,
    UsageReportRequest
)
import secrets
from datetime import datetime

router = APIRouter(prefix="/api/v1/openclaw", tags=["openclaw"])

# 1. 用户配置同步 API
@router.get("/users/configs")
async def get_users_configs(
    db: AsyncSession = Depends(get_db),
    # TODO: 添加 Gateway 服务认证中间件
):
    """供 Gateway 定期调用，获取所有用户配置"""

    # 查询所有活跃用户
    result = await db.execute(
        select(OpenclawUser, OpenclawSubscription)
        .join(OpenclawSubscription, OpenclawUser.user_id == OpenclawSubscription.user_id)
        .where(OpenclawUser.status == 'active')
    )

    users = []
    for openclaw_user, subscription in result:
        users.append({
            "userId": f"user_{openclaw_user.user_id}",
            "gatewayToken": openclaw_user.gateway_token,
            "config": {
                "models": {
                    "profiles": [{
                        "id": "default",
                        "provider": "openai",
                        "baseURL": openclaw_user.llm_base_url,
                        "apiKey": openclaw_user.llm_api_key,
                        "model": "gpt-4"
                    }]
                },
                **(openclaw_user.config or {})
            },
            "subscription": {
                "plan": subscription.plan,
                "credits": subscription.credits,
                "expiresAt": subscription.expires_at.isoformat() if subscription.expires_at else None
            }
        })

    return {"users": users}

# 2. 用户注册 API
@router.post("/users")
async def create_openclaw_user(
    request: CreateUserRequest,
    db: AsyncSession = Depends(get_db)
):
    """用户注册，分配 Gateway token 和 LLM API key"""

    # 查找或创建用户
    user = await get_or_create_user(db, request.email)

    # 检查是否已存在
    existing = await db.execute(
        select(OpenclawUser).where(OpenclawUser.user_id == user.id)
    )
    if existing.scalar_one_or_none():
        raise HTTPException(400, "User already exists")

    # 生成 Gateway token
    gateway_token = f"gt_{secrets.token_urlsafe(32)}"

    # 生成 LLM API key（代理 key）
    llm_api_key = f"sk-user{user.id}-{secrets.token_urlsafe(16)}"

    # 创建 Openclaw 用户配置
    openclaw_user = OpenclawUser(
        user_id=user.id,
        gateway_token=gateway_token,
        llm_api_key=llm_api_key,
        llm_base_url="https://your-cloud.com/api/llm",
        config={}
    )
    db.add(openclaw_user)

    # 创建订阅
    subscription = OpenclawSubscription(
        user_id=user.id,
        plan=request.plan,
        credits=get_initial_credits(request.plan),
        credits_total=get_initial_credits(request.plan)
    )
    db.add(subscription)

    await db.commit()

    return {
        "userId": f"user_{user.id}",
        "gatewayUrl": "wss://gateway.your-cloud.com:18789",
        "gatewayToken": gateway_token,
        "llmApiKey": llm_api_key,
        "llmBaseUrl": "https://your-cloud.com/api/llm"
    }

# 3. 使用统计上报 API
@router.post("/usage")
async def report_usage(
    request: UsageReportRequest,
    db: AsyncSession = Depends(get_db)
):
    """Gateway 上报用户使用量，扣除积分"""

    user_id = int(request.userId.replace("user_", ""))

    # 计算积分消耗
    credits_used = calculate_credits(
        request.usage.inputTokens,
        request.usage.outputTokens,
        request.usage.model
    )

    # 查询订阅
    result = await db.execute(
        select(OpenclawSubscription).where(OpenclawSubscription.user_id == user_id)
    )
    subscription = result.scalar_one_or_none()

    if not subscription:
        raise HTTPException(404, "Subscription not found")

    if subscription.credits < credits_used:
        raise HTTPException(402, "Insufficient credits")

    # 扣除积分
    subscription.credits -= credits_used

    # 记录使用日志
    usage_log = OpenclawUsageLog(
        user_id=user_id,
        timestamp=datetime.fromisoformat(request.timestamp.replace('Z', '+00:00')),
        model=request.usage.model,
        input_tokens=request.usage.inputTokens,
        output_tokens=request.usage.outputTokens,
        credits_used=credits_used
    )
    db.add(usage_log)

    await db.commit()

    return {
        "success": True,
        "creditsUsed": credits_used,
        "creditsRemaining": subscription.credits
    }

# 4. 用户积分查询 API
@router.get("/users/{user_id}/credits")
async def get_user_credits(
    user_id: str,
    db: AsyncSession = Depends(get_db)
):
    """查询用户剩余积分"""

    uid = int(user_id.replace("user_", ""))

    result = await db.execute(
        select(OpenclawSubscription).where(OpenclawSubscription.user_id == uid)
    )
    subscription = result.scalar_one_or_none()

    if not subscription:
        raise HTTPException(404, "Subscription not found")

    return {
        "credits": subscription.credits_total,
        "used": subscription.credits_total - subscription.credits,
        "remaining": subscription.credits,
        "plan": subscription.plan,
        "expiresAt": subscription.expires_at.isoformat() if subscription.expires_at else None
    }

# 辅助函数
def calculate_credits(input_tokens: int, output_tokens: int, model: str) -> int:
    """
    计算积分消耗
    
    注意：使用 math.ceil 精确计算，避免整除精度损失
    例如：999 tokens 也应计为 1 个计费单位，而非 0
    """
    import math
    
    # 模型费率配置（每 1000 tokens 的积分）
    MODEL_RATES = {
        "gpt-4": {"input": 10, "output": 30},
        "gpt-4-turbo": {"input": 5, "output": 15},
        "gpt-4o": {"input": 2.5, "output": 10},
        "gpt-3.5-turbo": {"input": 0.5, "output": 1.5},
        "claude-3-opus": {"input": 15, "output": 75},
        "claude-3-sonnet": {"input": 3, "output": 15},
        "claude-3-haiku": {"input": 0.25, "output": 1.25},
    }
    
    # 默认费率
    default_rate = {"input": 1, "output": 3}
    rate = MODEL_RATES.get(model, default_rate)
    
    # 精确计算（向上取整，确保不会因整除损失积分）
    input_credits = math.ceil(input_tokens * rate["input"] / 1000)
    output_credits = math.ceil(output_tokens * rate["output"] / 1000)
    
    return input_credits + output_credits

def get_initial_credits(plan: str) -> int:
    """根据套餐返回初始积分"""
    return {
        "free": 100,
        "pro": 10000,
        "enterprise": 100000
    }.get(plan, 100)

async def get_or_create_user(db: AsyncSession, email: str):
    """查找或创建用户"""
    from backend.app.models.user import User

    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()

    if not user:
        user = User(email=email)
        db.add(user)
        await db.commit()
        await db.refresh(user)

    return user
```

---

### 3.3 LLM 代理服务（积分扣费）

**文件**：`backend/app/api/v1/llm_proxy.py`

```python
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from backend.database import get_db
from backend.app.models.openclaw import OpenclawUser, OpenclawSubscription
import httpx
import os

router = APIRouter(prefix="/api/llm", tags=["llm-proxy"])

@router.post("/v1/chat/completions")
async def proxy_chat_completions(
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """LLM API 代理，验证 API key 并转发请求"""

    # 1. 验证 API key
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(401, "Invalid API key")

    api_key = auth_header.replace("Bearer ", "")

    # 查找用户
    result = await db.execute(
        select(OpenclawUser).where(OpenclawUser.llm_api_key == api_key)
    )
    openclaw_user = result.scalar_one_or_none()

    if not openclaw_user:
        raise HTTPException(401, "Invalid API key")

    # 2. 检查积分
    sub_result = await db.execute(
        select(OpenclawSubscription).where(OpenclawSubscription.user_id == openclaw_user.user_id)
    )
    subscription = sub_result.scalar_one_or_none()

    if not subscription or subscription.credits <= 0:
        raise HTTPException(402, "Insufficient credits")

    # 3. 转发请求到真实 LLM API
    body = await request.json()

    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://api.openai.com/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {os.getenv('OPENAI_API_KEY')}",
                "Content-Type": "application/json"
            },
            json=body,
            timeout=60.0
        )

    if response.status_code != 200:
        raise HTTPException(response.status_code, response.text)

    response_data = response.json()

    # 4. 记录使用量（异步任务，不阻塞响应）
    usage = response_data.get("usage", {})
    if usage:
        # TODO: 使用 Celery 异步任务
        await report_usage_internal(
            db=db,
            user_id=openclaw_user.user_id,
            model=body.get("model", "gpt-4"),
            input_tokens=usage.get("prompt_tokens", 0),
            output_tokens=usage.get("completion_tokens", 0)
        )

    return response_data

async def report_usage_internal(
    db: AsyncSession,
    user_id: int,
    model: str,
    input_tokens: int,
    output_tokens: int
):
    """内部使用量记录"""
    from backend.app.api.v1.openclaw import calculate_credits
    from backend.app.models.openclaw import OpenclawUsageLog
    from datetime import datetime

    credits_used = calculate_credits(input_tokens, output_tokens, model)

    # 扣除积分
    result = await db.execute(
        select(OpenclawSubscription).where(OpenclawSubscription.user_id == user_id)
    )
    subscription = result.scalar_one_or_none()

    if subscription:
        subscription.credits -= credits_used

    # 记录日志
    usage_log = OpenclawUsageLog(
        user_id=user_id,
        timestamp=datetime.now(),
        model=model,
        input_tokens=input_tokens,
        output_tokens=output_tokens,
        credits_used=credits_used
    )
    db.add(usage_log)

    await db.commit()
```

---

## 4. 集成到现有后端项目

### 4.1 添加数据库迁移

```bash
# 请替换为您的实际后端项目路径
cd <your-backend-project>

# 生成迁移脚本
uv run alembic revision --autogenerate -m "add openclaw tables"

# 执行迁移
uv run alembic upgrade head
```

---

### 4.2 添加路由

**文件**：`<your-backend-project>/app/api/router.py`

```python
from backend.app.api.v1 import openclaw, llm_proxy

# 添加路由
api_router.include_router(openclaw.router)
api_router.include_router(llm_proxy.router)
```

---

### 4.3 配置环境变量

**文件**：`<your-backend-project>/.env`

```bash
# Openclaw 配置
OPENCLAW_GATEWAY_SERVICE_TOKEN=<生成一个服务间认证 token>
OPENAI_API_KEY=<你的 OpenAI API key>

# Gateway URL
OPENCLAW_GATEWAY_URL=wss://gateway.your-cloud.com:18789
```

---

### 4.4 部署 Gateway

```bash
# 在云端服务器上

# 1. 创建数据目录
mkdir -p /data/openclaw/{configs,workspaces,logs}

# 2. 创建模板工作区
mkdir -p /data/openclaw/workspaces/template
cat > /data/openclaw/workspaces/template/AGENTS.md <<EOF
# Agent 行为指南

你是一个有帮助的 AI 助手。
EOF

# 3. 创建全局配置
cat > /etc/openclaw/config.json <<EOF
{
  "multiTenant": {
    "enabled": true,
    "cloudBackendUrl": "https://your-cloud-backend.com",
    "configRoot": "/data/openclaw/configs",
    "workspaceRoot": "/data/openclaw/workspaces",
    "templatePath": "/data/openclaw/workspaces/template",
    "maxCachedUsers": 100,
    "userIdleTimeoutMs": 3600000,
    "syncIntervalMs": 300000
  },
  "gateway": {
    "port": 18789,
    "bind": "0.0.0.0"
  }
}
EOF

# 4. 设置环境变量
export OPENCLAW_SERVICE_TOKEN=<服务间认证 token>

# 5. 安装 Openclaw（改造后的版本）
npm install -g openclaw@latest

# 6. 启动 Gateway
openclaw gateway --port 18789 --bind 0.0.0.0

# 或使用 systemd 服务
cat > /etc/systemd/system/openclaw-gateway.service <<EOF
[Unit]
Description=Openclaw Gateway
After=network.target

[Service]
Type=simple
User=openclaw
WorkingDirectory=/data/openclaw
Environment="OPENCLAW_SERVICE_TOKEN=<token>"
ExecStart=/usr/bin/openclaw gateway --port 18789 --bind 0.0.0.0
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable openclaw-gateway
systemctl start openclaw-gateway
```

---

## 5. 用户使用流程

### 5.1 用户注册

```bash
# 用户在前端注册
POST https://your-cloud-backend.com/api/v1/openclaw/users
{
  "email": "user@example.com",
  "plan": "pro"
}

# 返回
{
  "userId": "user_123",
  "gatewayUrl": "wss://gateway.your-cloud.com:18789",
  "gatewayToken": "gt_abc123xyz",
  "llmApiKey": "sk-user123-xxx",
  "llmBaseUrl": "https://your-cloud.com/api/llm"
}
```

### 5.2 用户配置客户端

用户在 Openclaw 客户端配置：
- Gateway URL: `wss://gateway.your-cloud.com:18789`
- Auth Token: `gt_abc123xyz`

### 5.3 用户连接

客户端自动连接到 Gateway，Gateway 验证 token 并加载用户配置。

---

## 6. 安全加固

### 6.1 敏感信息存储

**问题**：API key 明文存储在文件中存在安全风险

**解决方案**：

```python
# 使用加密存储 API key
from cryptography.fernet import Fernet
import os

class SecureCredentialStore:
    def __init__(self):
        # 从环境变量获取加密密钥
        key = os.getenv('CREDENTIAL_ENCRYPTION_KEY')
        self.cipher = Fernet(key.encode())
    
    def encrypt(self, plaintext: str) -> str:
        return self.cipher.encrypt(plaintext.encode()).decode()
    
    def decrypt(self, ciphertext: str) -> str:
        return self.cipher.decrypt(ciphertext.encode()).decode()

# 在数据库中存储加密后的 API key
openclaw_user.llm_api_key_encrypted = credential_store.encrypt(api_key)
```

**Gateway 端**：可以参考现有的 `ensureAuthProfileStore()` 实现，使用系统 Keychain/Secret Store

### 6.2 配置同步安全

**问题**：全量同步可能泄露所有用户配置

**解决方案**：

```python
# 1. 增量同步：只同步变更的用户配置
@router.get("/users/configs")
async def get_users_configs(
    since: Optional[str] = Query(None, description="ISO 8601 时间戳"),
    db: AsyncSession = Depends(get_db)
):
    query = select(OpenclawUser).where(OpenclawUser.status == 'active')
    if since:
        since_dt = datetime.fromisoformat(since.replace('Z', '+00:00'))
        query = query.where(OpenclawUser.updated_at > since_dt)
    # ...

# 2. 签名验证：对同步数据进行签名
import hmac
import hashlib

def sign_response(data: dict, secret: str) -> str:
    payload = json.dumps(data, sort_keys=True)
    return hmac.new(secret.encode(), payload.encode(), hashlib.sha256).hexdigest()

# 3. 传输加密：强制 HTTPS + 证书校验
# 在 Gateway 端配置：
TLS_VERIFY=true
```

### 6.3 租户隔离验证

**原则**：每次请求处理前都要验证 userId 与 token 匹配

```typescript
// 在 Agent 请求处理中验证租户隔离
async function handleAgentRequest(
  params: AgentParams,
  client: GatewayWsClient
): Promise<AgentResponse> {
  // 必须验证请求来自已认证的租户
  if (!client.multiTenant?.userId) {
    throw new Error('Tenant context not found');
  }
  
  const { userId, userInstance } = client.multiTenant;
  
  // 确保只能访问自己的工作区
  const requestedWorkspace = params.workspacePath;
  if (requestedWorkspace && !requestedWorkspace.includes(userId)) {
    throw new Error('Access denied: cross-tenant workspace access');
  }
  
  // 记录审计日志
  console.log(`[Audit] User ${userId} requested agent action`);
  
  // ... 继续处理
}
```

### 6.4 服务间认证

**问题**：简单的 Bearer Token 安全性不足

**解决方案**：

```python
# 使用 JWT + 短有效期
import jwt
from datetime import datetime, timedelta

def create_service_token(service_id: str, secret: str) -> str:
    payload = {
        'sub': service_id,
        'iat': datetime.utcnow(),
        'exp': datetime.utcnow() + timedelta(minutes=5),  # 5 分钟有效期
    }
    return jwt.encode(payload, secret, algorithm='HS256')

def verify_service_token(token: str, secret: str) -> dict:
    return jwt.decode(token, secret, algorithms=['HS256'])

# Gateway 端调用时生成新 token
token = create_service_token('openclaw-gateway', os.getenv('SERVICE_SECRET'))
headers = {'Authorization': f'Bearer {token}'}
```

### 6.5 其他安全建议

- **速率限制**：对 API 请求进行限流，防止滥用
- **日志审计**：记录所有敏感操作
- **异常检测**：监控异常模式（如短时间大量请求）
- **定期轮换**：定期轮换 API key 和服务 token

---

## 总结

云端服务需要提供：

1. **用户管理 API**：注册、配置同步、积分查询
2. **LLM 代理服务**：统一计费、流量控制
3. **使用量上报**：记录使用、扣除积分
4. **数据库表**：用户配置、订阅、使用日志
5. **安全加固**：加密存储、签名验证、租户隔离

集成步骤：

1. 添加数据库表和迁移
2. 实现 API 路由
3. 部署 Gateway 服务
4. 配置环境变量
5. **实施安全加固措施**

至此，完整的多租户 SaaS 化改造方案设计完成！
