# Openclaw 多租户 SaaS 化改造方案 - 核心流程设计

## 1. 用户注册与配置分配流程

### 流程图

```
用户 → 云端服务 → Openclaw Gateway

┌─────────────────────────────────────────────────────────────┐
│ 1. 用户注册                                                  │
│    ├─ 用户在云端服务注册账号                                 │
│    ├─ 云端服务生成：                                         │
│    │  ├─ userId: user_123                                   │
│    │  ├─ gatewayToken: gt_abc123xyz (唯一)                 │
│    │  ├─ llmApiKey: sk-xxx (从云端 LLM 代理分配)            │
│    │  └─ llmBaseUrl: https://your-cloud.com/api/llm        │
│    └─ 返回给用户：                                           │
│       ├─ Gateway URL: wss://gateway.your-cloud.com:18789   │
│       └─ Auth Token: gt_abc123xyz                          │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 2. 配置同步到 Gateway                                        │
│    ├─ Gateway 定期调用云端 API：                             │
│    │  GET /api/v1/openclaw/users/configs                    │
│    │  Response: [                                           │
│    │    {                                                   │
│    │      userId: "user_123",                              │
│    │      gatewayToken: "gt_abc123xyz",                    │
│    │      config: {                                         │
│    │        models: {                                       │
│    │          profiles: [{                                  │
│    │            id: "default",                             │
│    │            provider: "openai",                        │
│    │            baseURL: "https://your-cloud.com/api/llm", │
│    │            apiKey: "sk-xxx"                           │
│    │          }]                                            │
│    │        }                                               │
│    │      }                                                 │
│    │    }                                                   │
│    │  ]                                                     │
│    │                                                        │
│    └─ Gateway 写入本地：                                     │
│       /data/openclaw/configs/users/user_123/                │
│       ├─ openclaw.json (用户配置)                            │
│       └─ token (gatewayToken)                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 3. 用户首次连接                                              │
│    ├─ 客户端配置：                                           │
│    │  ├─ Gateway URL: wss://gateway.your-cloud.com:18789  │
│    │  └─ Auth Token: gt_abc123xyz                         │
│    │                                                        │
│    ├─ 客户端发送 connect 请求                               │
│    │  {                                                     │
│    │    type: "req",                                       │
│    │    method: "connect",                                 │
│    │    params: {                                          │
│    │      auth: { token: "gt_abc123xyz" }                 │
│    │    }                                                   │
│    │  }                                                     │
│    │                                                        │
│    ├─ Gateway 验证 token                                    │
│    │  ├─ 查找 tokenToUserId 映射                           │
│    │  ├─ 找到 userId: user_123                            │
│    │  └─ 懒加载用户实例                                     │
│    │                                                        │
│    ├─ 初始化用户工作区                                       │
│    │  /data/openclaw/workspaces/users/user_123/            │
│    │  ├─ memory/                                           │
│    │  ├─ sessions/                                         │
│    │  └─ custom/                                           │
│    │                                                        │
│    └─ 返回 hello-ok                                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 客户端连接认证流程

### 现有认证机制说明

Openclaw 现有架构支持多种认证方式，多租户改造需要兼容这些机制：

**现有认证方式**：
- **Token 认证**：多租户主要使用，需要扩展支持多用户 token
- **Password 认证**：考虑在多租户模式下禁用或映射到租户
- **Tailscale 认证**：保持现有逻辑，可能需要映射到租户
- **设备配对认证**：考虑是否需要租户级别的设备管理

### 现有认证代码结构

```typescript
// src/gateway/auth.ts - 现有结构（勿破坏）

// 认证结果类型
export type GatewayAuthResult = {
  ok: boolean;
  method?: "token" | "password" | "tailscale" | "device-token";
  user?: string;
  reason?: string;
};

// 核心认证函数（异步，支持 Tailscale whois 验证）
export async function authorizeGatewayConnect(params: {
  auth: ResolvedGatewayAuth;
  connectAuth?: ConnectAuth | null;
  req?: IncomingMessage;
  trustedProxies?: string[];
  tailscaleWhois?: TailscaleWhoisLookup;
}): Promise<GatewayAuthResult>;
```

### 多租户认证扩展方案

```typescript
// src/gateway/auth.ts - 扩展而非替换

import type { MultiTenantGatewayManager } from './multi-tenant-manager.js';

/**
 * 多租户认证扩展
 * 
 * 设计原则：
 * 1. 不破坏现有 authorizeGatewayConnect 的签名
 * 2. 通过可选参数添加多租户支持
 * 3. 保持向后兼容
 */
export async function authorizeGatewayConnectMultiTenant(params: {
  auth: ResolvedGatewayAuth;
  connectAuth?: ConnectAuth | null;
  req?: IncomingMessage;
  trustedProxies?: string[];
  tailscaleWhois?: TailscaleWhoisLookup;
  // 多租户扩展参数
  multiTenantManager?: MultiTenantGatewayManager;
}): Promise<GatewayAuthResult & { userId?: string }> {
  const { multiTenantManager, connectAuth, ...baseParams } = params;

  // 多租户模式：优先使用 token 查找用户
  if (multiTenantManager && connectAuth?.token) {
    const userId = await multiTenantManager.authenticateToken(connectAuth.token);
    if (userId) {
      return {
        ok: true,
        method: 'token',
        userId,
      };
    }
    // token 无效时返回失败（多租户模式不回退到单用户认证）
    return {
      ok: false,
      reason: 'token_mismatch',
    };
  }

  // 非多租户模式：回退到现有认证逻辑
  return await authorizeGatewayConnect({
    ...baseParams,
    connectAuth,
  });
}
```

### Connect 请求处理

```typescript
// src/gateway/server/ws-connection/message-handler.ts
// 
// 注意：现有代码使用 setClient()/getClient() 管理连接状态
// 而非直接操作 ws.userData

import { authorizeGatewayConnectMultiTenant } from '../../auth.js';
import type { GatewayWsClient } from '../ws-types.js';

// 在 attachGatewayWsMessageHandler 中处理连接
async function handleConnectRequest(
  params: ConnectParams,
  context: {
    socket: WebSocket;
    resolvedAuth: ResolvedGatewayAuth;
    multiTenantManager?: MultiTenantGatewayManager;
    setClient: (client: GatewayWsClient) => void;
    getClient: () => GatewayWsClient | null;
  }
): Promise<ConnectResponse> {
  const { socket, resolvedAuth, multiTenantManager, setClient } = context;

  // 1. 认证（使用扩展后的多租户认证函数）
  const authResult = await authorizeGatewayConnectMultiTenant({
    auth: resolvedAuth,
    connectAuth: params.auth,
    multiTenantManager,
  });

  if (!authResult.ok) {
    throw new Error(`Unauthorized: ${authResult.reason}`);
  }

  // 2. 多租户模式：绑定用户上下文
  if (authResult.userId && multiTenantManager) {
    const userInstance = await multiTenantManager.getUserInstance(authResult.userId);
    userInstance.connections.add(socket);

    // 使用现有的 setClient 方法（而非直接操作 ws.userData）
    setClient({
      // ... 现有字段
      // 扩展多租户字段
      multiTenant: {
        userId: authResult.userId,
        userInstance,
        config: userInstance.config,
        workspacePath: userInstance.workspacePath,
        workspaceResolver: userInstance.workspaceResolver,
      },
    } as GatewayWsClient);

    console.log(`[Gateway] User ${authResult.userId} connected`);
  }

  // 3. 返回 hello-ok
  return {
    type: 'hello-ok',
    protocol: PROTOCOL_VERSION,
    policy: { tickIntervalMs: TICK_INTERVAL_MS },
  };
}
```

### 连接关闭时清理

```typescript
// 在连接关闭时移除用户连接记录
function handleDisconnect(
  socket: WebSocket,
  client: GatewayWsClient | null,
  multiTenantManager?: MultiTenantGatewayManager
): void {
  if (client?.multiTenant && multiTenantManager) {
    const { userId, userInstance } = client.multiTenant;
    userInstance.connections.delete(socket);
    console.log(`[Gateway] User ${userId} disconnected`);
  }
}
```

---

## 3. Agent 请求处理流程（多租户隔离）

### 流程图

```
客户端 → Gateway → 用户实例 → LLM → 响应

┌─────────────────────────────────────────────────────────────┐
│ 1. 客户端发送 agent 请求                                     │
│    {                                                         │
│      type: "req",                                           │
│      method: "agent",                                       │
│      params: {                                              │
│        message: "帮我写一个 Python 脚本"                     │
│      }                                                       │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Gateway 从连接获取用户上下文                              │
│    const { userId, userInstance } = ws.userData;            │
│    const config = userInstance.config;                      │
│    const workspaceResolver = userInstance.workspaceResolver;│
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 读取用户工作区文件                                        │
│    const agentsMd = await workspaceResolver                 │
│      .readWorkspaceFile('AGENTS.md');                       │
│    const soulMd = await workspaceResolver                   │
│      .readWorkspaceFile('SOUL.md');                         │
│    const userMd = await workspaceResolver                   │
│      .readWorkspaceFile('USER.md');                         │
│    const todayMemory = await workspaceResolver              │
│      .readTodayMemory();                                    │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 构建系统提示（包含用户工作区内容）                        │
│    const systemPrompt = buildSystemPrompt({                 │
│      agentsMd,                                              │
│      soulMd,                                                │
│      userMd,                                                │
│      todayMemory,                                           │
│      // ... 其他上下文                                      │
│    });                                                       │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 调用 LLM（使用用户专属 API key）                         │
│    const llmResponse = await callLLM({                      │
│      baseURL: config.models.profiles[0].baseURL,           │
│      apiKey: config.models.profiles[0].apiKey,             │
│      model: config.models.profiles[0].model,               │
│      messages: [                                            │
│        { role: 'system', content: systemPrompt },          │
│        { role: 'user', content: params.message }           │
│      ]                                                       │
│    });                                                       │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 保存会话记录到用户工作区                                  │
│    await saveSession(                                        │
│      `${workspacePath}/sessions/${Date.now()}.jsonl`,      │
│      llmResponse                                            │
│    );                                                        │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 返回响应给客户端                                          │
│    {                                                         │
│      type: "res",                                           │
│      ok: true,                                              │
│      payload: {                                             │
│        runId: "run_xxx",                                   │
│        status: "completed",                                │
│        summary: llmResponse.content                        │
│      }                                                       │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
```

### 代码实现

```typescript
// src/gateway/server-methods/agent.ts

async function handleAgentRequest(
  ws: WebSocket,
  params: AgentRequestParams
): Promise<AgentResponse> {

  // 1. 从连接获取用户上下文
  const { userId, userInstance } = ws.userData;

  if (!userId || !userInstance) {
    throw new Error('User context not found');
  }

  const config = userInstance.config;
  const workspaceResolver = userInstance.workspaceResolver;

  console.log(`[Agent] Processing request for user ${userId}`);

  // 2. 读取工作区文件（优先用户自定义，回退模板）
  const agentsMd = await workspaceResolver.readWorkspaceFile('AGENTS.md');
  const soulMd = await workspaceResolver.readWorkspaceFile('SOUL.md');
  const userMd = await workspaceResolver.readWorkspaceFile('USER.md');
  const todayMemory = await workspaceResolver.readTodayMemory();

  // 3. 构建系统提示
  const systemPrompt = buildSystemPrompt({
    agentsMd,
    soulMd,
    userMd,
    todayMemory,
    timestamp: new Date().toISOString(),
    // ... 其他上下文
  });

  // 4. 调用 LLM（使用用户专属配置）
  const profile = config.models.profiles[0];
  const llmResponse = await callLLM({
    baseURL: profile.baseURL,
    apiKey: profile.apiKey,
    model: profile.model || 'gpt-4',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: params.message }
    ],
    stream: true,
    onChunk: (chunk) => {
      // 流式返回给客户端
      ws.send(JSON.stringify({
        type: 'event',
        event: 'agent.chunk',
        payload: { content: chunk }
      }));
    }
  });

  // 5. 保存会话记录
  const sessionPath = `${userInstance.workspacePath}/sessions/${Date.now()}.jsonl`;
  await saveSession(sessionPath, {
    timestamp: new Date().toISOString(),
    userId,
    request: params,
    response: llmResponse
  });

  // 6. 上报使用量到云端（异步）
  reportUsageAsync({
    userId,
    timestamp: new Date().toISOString(),
    model: profile.model,
    inputTokens: llmResponse.usage.prompt_tokens,
    outputTokens: llmResponse.usage.completion_tokens
  }).catch(err => {
    console.error('[Agent] Failed to report usage:', err);
  });

  // 7. 返回响应
  return {
    runId: generateRunId(),
    status: 'completed',
    summary: llmResponse.content,
    usage: llmResponse.usage
  };
}
```

---

## 4. 配置同步机制

### 定期同步流程

```
Gateway 启动 → 立即同步 → 定期同步（5分钟）

┌─────────────────────────────────────────────────────────────┐
│ Gateway 启动时                                               │
│ ├─ 加载全局配置                                              │
│ ├─ 初始化 MultiTenantGatewayManager                        │
│ ├─ 立即同步用户配置（syncUserConfigs）                      │
│ └─ 启动 ConfigSyncService                                   │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 每 5 分钟执行一次                                            │
│ ├─ 调用云端 API: GET /api/v1/openclaw/users/configs        │
│ ├─ 更新 tokenToUserId 映射                                 │
│ ├─ 写入本地配置文件                                          │
│ └─ 日志：[ConfigSync] Synced N user configs                │
└─────────────────────────────────────────────────────────────┘
```

### 实现代码

```typescript
// src/gateway/config-sync.ts

export class ConfigSyncService {
  private syncInterval: NodeJS.Timeout | null = null;

  constructor(
    private manager: MultiTenantGatewayManager,
    private intervalMs: number
  ) {}

  start(): void {
    // 立即同步一次
    this.sync();

    // 定期同步
    this.syncInterval = setInterval(() => {
      this.sync();
    }, this.intervalMs);

    console.log(`[ConfigSync] Started (interval: ${this.intervalMs}ms)`);
  }

  stop(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
      console.log('[ConfigSync] Stopped');
    }
  }

  private async sync(): Promise<void> {
    try {
      const startTime = Date.now();
      await this.manager.syncUserConfigs();
      const duration = Date.now() - startTime;
      console.log(`[ConfigSync] Completed in ${duration}ms`);
    } catch (error) {
      console.error('[ConfigSync] Failed:', error);
    }
  }
}
```

---

## 5. 用户实例清理机制（LRU）

### 清理流程

```
定期检查（每小时） → 识别空闲用户 → 清理实例

┌─────────────────────────────────────────────────────────────┐
│ 每小时执行一次                                               │
│ ├─ 遍历所有用户实例                                          │
│ ├─ 检查条件：                                                │
│ │  ├─ 没有活跃连接（connections.size === 0）               │
│ │  └─ 超过空闲时间（now - lastAccess > 1小时）             │
│ ├─ 删除符合条件的实例                                        │
│ └─ 日志：[MultiTenant] Cleaned up N inactive users         │
└─────────────────────────────────────────────────────────────┘
```

### 实现代码

```typescript
// src/gateway/multi-tenant-manager.ts

async cleanupInactiveUsers(): Promise<void> {
  const now = Date.now();
  const cleaned: string[] = [];

  for (const [userId, instance] of this.userInstances) {
    // 如果没有活跃连接且超过空闲时间，清理
    if (instance.connections.size === 0 &&
        now - instance.lastAccess > this.config.userIdleTimeoutMs) {
      this.userInstances.delete(userId);
      cleaned.push(userId);
    }
  }

  if (cleaned.length > 0) {
    console.log(`[MultiTenant] Cleaned up ${cleaned.length} inactive users: ${cleaned.join(', ')}`);
  }
}
```

---

## 6. 使用量上报流程

### 流程图

```
LLM 调用完成 → 计算 tokens → 上报云端 → 扣除积分

┌─────────────────────────────────────────────────────────────┐
│ 1. LLM 调用完成，获取 usage                                  │
│    {                                                         │
│      prompt_tokens: 1000,                                   │
│      completion_tokens: 500,                                │
│      total_tokens: 1500                                     │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 异步上报到云端 API                                        │
│    POST /api/v1/openclaw/usage                               │
│    {                                                         │
│      userId: "user_123",                                    │
│      timestamp: "2026-01-30T12:00:00Z",                    │
│      usage: {                                               │
│        inputTokens: 1000,                                   │
│        outputTokens: 500,                                   │
│        model: "gpt-4"                                       │
│      }                                                       │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 云端服务处理                                              │
│    ├─ 计算积分消耗                                           │
│    ├─ 扣除用户积分                                           │
│    ├─ 记录使用日志                                           │
│    └─ 返回剩余积分                                           │
└─────────────────────────────────────────────────────────────┘
```

### 实现代码

```typescript
// src/gateway/usage-reporter.ts

export async function reportUsageAsync(data: {
  userId: string;
  timestamp: string;
  model: string;
  inputTokens: number;
  outputTokens: number;
}): Promise<void> {
  const globalConfig = loadGlobalConfig();
  const cloudBackendUrl = globalConfig.multiTenant?.cloudBackendUrl;

  if (!cloudBackendUrl) {
    console.warn('[Usage] Cloud backend URL not configured, skipping report');
    return;
  }

  try {
    const response = await fetch(`${cloudBackendUrl}/api/v1/openclaw/usage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENCLAW_SERVICE_TOKEN}`
      },
      body: JSON.stringify({
        userId: data.userId,
        timestamp: data.timestamp,
        usage: {
          inputTokens: data.inputTokens,
          outputTokens: data.outputTokens,
          model: data.model
        }
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const result = await response.json();
    console.log(`[Usage] Reported for ${data.userId}, remaining credits: ${result.creditsRemaining}`);
  } catch (error) {
    console.error('[Usage] Failed to report:', error);
    // 不抛出错误，避免影响主流程
  }
}
```

---

## 总结

核心流程包括：

1. **用户注册流程**：云端生成配置 → 同步到 Gateway → 用户连接
2. **认证流程**：Token 验证 → 懒加载用户实例 → 绑定上下文
3. **请求处理流程**：读取工作区 → 调用 LLM → 保存会话 → 上报使用量
4. **配置同步**：定期从云端拉取最新配置
5. **实例清理**：LRU 清理长时间未使用的用户实例
6. **使用量上报**：异步上报到云端，扣除积分

下一步请阅读 **04-Openclaw改造清单.md**。
